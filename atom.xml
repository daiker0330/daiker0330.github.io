<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Daiker's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://daiker0330.github.io//"/>
  <updated>2015-07-27T02:04:50.720Z</updated>
  <id>http://daiker0330.github.io//</id>
  
  <author>
    <name><![CDATA[Daiker0330]]></name>
    <email><![CDATA[daiker0330@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[设计模式]]></title>
    <link href="http://daiker0330.github.io/2015/07/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://daiker0330.github.io/2015/07/27/设计模式/</id>
    <published>2015-07-27T01:41:51.000Z</published>
    <updated>2015-07-27T02:04:50.720Z</updated>
    <content type="html"><![CDATA[<h1 id="设计模式">设计模式</h1><h2 id="第1章_引言">第1章 引言</h2><ul>
<li>相互通信的对象 communicating object</li>
</ul>
<h3 id="1-1_什么是设计模式">1.1 什么是设计模式</h3><p>四个基本要素:</p>
<ul>
<li>模式名称 pattern name</li>
<li>问题 problem</li>
<li>解决方法 solution</li>
<li>效果 consequences</li>
</ul>
<h3 id="1-2_Smalltalk_MVC中的设计模式">1.2 Smalltalk MVC中的设计模式</h3><h3 id="1-3_描述设计模式">1.3 描述设计模式</h3><ul>
<li>模式名和分类</li>
<li>意图</li>
<li>别名</li>
<li>动机</li>
<li>适用性</li>
<li>结构</li>
<li>参与者</li>
<li>协作</li>
<li>效果</li>
<li>实现</li>
<li>代码示例</li>
<li>已知应用</li>
<li>相关模式</li>
</ul>
<h3 id="1-4_设计模式的编目">1.4 设计模式的编目</h3><ul>
<li>Abstract Factory</li>
<li>Adapter</li>
<li>Bridge</li>
<li>Builder</li>
<li>Chain of Responsibility</li>
<li>Command</li>
<li>Decorator</li>
<li>Facade</li>
<li>Factory Method</li>
<li>Flyweight</li>
<li>Interpreter</li>
<li>Iterator</li>
<li>Mediator</li>
<li>Memento</li>
<li>Observer</li>
<li>Prototype</li>
<li>Proxy</li>
<li>Singleton</li>
<li>State</li>
<li>Strategy</li>
<li>Template Method</li>
<li>Visitor</li>
</ul>
<h3 id="1-5_组织编目">1.5 组织编目</h3><p>目的:</p>
<ul>
<li>创建型 Creational</li>
<li>结构性 Structural</li>
<li>行为型 Behavioral</li>
</ul>
<p>范围:</p>
<ul>
<li>类</li>
<li>对象</li>
</ul>
<h3 id="1-6_设计模式怎样解决设计问题">1.6 设计模式怎样解决设计问题</h3><h4 id="1-6-1_寻找合适的对象">1.6.1 寻找合适的对象</h4><h4 id="1-6-2_决定对象的粒度">1.6.2 决定对象的粒度</h4><h4 id="1-6-3_指定对象的接口">1.6.3 指定对象的接口</h4><ul>
<li>型构 signature</li>
<li>接口 interface</li>
<li>类型 type</li>
<li>子类型 subtype</li>
<li>超类型 supertype</li>
<li>动态绑定 dynamic binding</li>
<li>多态 polymorphism</li>
</ul>
<h4 id="描述对象的实现">描述对象的实现</h4><ul>
<li>类继承 class inheritance</li>
<li>子类 subclass</li>
<li>父类 parent class</li>
<li>抽象类 abstract class</li>
<li>抽象操作 abstract operation</li>
<li>具体类 concrete class</li>
<li>重定义 override</li>
<li>混入类 mixin class</li>
</ul>
<p><strong>原则</strong>:</p>
<ul>
<li>针对接口编程, 而不是对针对实现编程</li>
</ul>
<h4 id="1-6-5_运用复用机制">1.6.5 运用复用机制</h4><ul>
<li>对象组合 object composition</li>
<li>白箱复用 white-box reuse</li>
<li>黑箱复用 black-box reuse</li>
<li>委托 delegation</li>
<li>代理者 delegate</li>
<li>参数化类型 parameterized type</li>
<li>类属 generic</li>
<li>模板 templates</li>
</ul>
<p><strong>原则</strong>:</p>
<ul>
<li>优先使用对象组合, 而不是类继承</li>
</ul>
<h4 id="1-6-6_关联运行时刻和编译时刻的结构">1.6.6 关联运行时刻和编译时刻的结构</h4><ul>
<li>聚合 aggregation</li>
<li>相识 acquaintance</li>
</ul>
<h4 id="1-6-7_设计应支持变化">1.6.7 设计应支持变化</h4><p>软件系统:</p>
<ul>
<li>应用程序 Application Program</li>
<li>工具箱 Toolkit</li>
<li>框架 Framework</li>
</ul>
<h3 id="1-7_怎样选择设计模式">1.7 怎样选择设计模式</h3><h3 id="1-8_怎样使用设计模式">1.8 怎样使用设计模式</h3><ol>
<li>大致浏览一遍模式</li>
<li>回头研究结构部分, 参与者部分和协作部分</li>
<li>看代码示例部分, 看看这个模式代码形式的具体例子</li>
<li>选择模式参与者的名字, 使他们在应用上下文中有意义</li>
<li>定义类</li>
<li>定义模式中专用于应用的操作名称</li>
<li>实现执行模式中责任和协作的操作</li>
</ol>
<h2 id="第2章_实例研究:_设计一个文档编辑器">第2章 实例研究: 设计一个文档编辑器</h2><ul>
<li>所见即所得 WYSIWYG</li>
</ul>
<h3 id="2-1_设计问题">2.1 设计问题</h3><ol>
<li>文档结构</li>
<li>格式化</li>
<li>修饰用户界面</li>
<li>支持多种视感(look-and-feel)标准</li>
<li>支持多种窗口系统</li>
<li>用户操作</li>
<li>拼写检查和连字符</li>
</ol>
<h3 id="2-2_文档结构">2.2 文档结构</h3><h4 id="2-2-1_递归组合">2.2.1 递归组合</h4><ul>
<li>递归组合 Recursive Composition</li>
</ul>
<h4 id="2-2-2_图元">2.2.2 图元</h4><ul>
<li>图元 Glyph</li>
</ul>
<h4 id="2-2-3_组合模式">2.2.3 组合模式</h4><h3 id="2-3_格式化">2.3 格式化</h3><ul>
<li>格式化 formatting</li>
<li>分行 linebreaking</li>
</ul>
<h4 id="2-3-1_封装格式化算法">2.3.1 封装格式化算法</h4><h4 id="2-3-2_Compositor和Composition">2.3.2 Compositor和Composition</h4><h4 id="2-3-3_策略模式">2.3.3 策略模式</h4><h3 id="2-4_修饰用户界面">2.4 修饰用户界面</h3><h4 id="2-4-1_透明围栏">2.4.1 透明围栏</h4><ul>
<li>透明围栏 Transparent Enclosure</li>
</ul>
<h4 id="2-4-2_MonoGlyph">2.4.2 MonoGlyph</h4><h4 id="2-4-3_Decorator模式">2.4.3 Decorator模式</h4><h3 id="2-5_支持多种视感标准">2.5 支持多种视感标准</h3><h4 id="2-5-1_对象创建的抽象">2.5.1 对象创建的抽象</h4><h4 id="2-5-2_工厂类和产品类">2.5.2 工厂类和产品类</h4><h4 id="2-5-3_Abstract_Factory模式">2.5.3 Abstract Factory模式</h4><h3 id="2-6_支持多种窗口系统">2.6 支持多种窗口系统</h3><h4 id="2-6-1_我们是否可以使用Abstract_Factory模式">2.6.1 我们是否可以使用Abstract Factory模式</h4><h4 id="2-6-2_封装实现依赖关系">2.6.2 封装实现依赖关系</h4><p><strong>对变化的概念进行封装</strong></p>
<h4 id="2-6-3_Window和WindowImp">2.6.3 Window和WindowImp</h4><h4 id="2-6-4_Bridge模式">2.6.4 Bridge模式</h4><h3 id="2-7_用户操作">2.7 用户操作</h3><h4 id="2-7-1_封装一个请求">2.7.1 封装一个请求</h4><h4 id="2-7-2_Command类及其子类">2.7.2 Command类及其子类</h4><h4 id="2-7-3_撤销和重做">2.7.3 撤销和重做</h4><h4 id="2-7-4_命令历史记录">2.7.4 命令历史记录</h4><h4 id="2-7-5_Command模式">2.7.5 Command模式</h4><h3 id="2-8_拼写检查和断字处理">2.8 拼写检查和断字处理</h3><h4 id="2-8-1_访问分散的信息">2.8.1 访问分散的信息</h4><h4 id="2-8-2_封装访问和遍历">2.8.2 封装访问和遍历</h4><h4 id="2-8-3_Iterator类及其子类">2.8.3 Iterator类及其子类</h4><h4 id="2-8-4_Iterator模式">2.8.4 Iterator模式</h4><h4 id="2-8-5_遍历和遍历过程中的动作">2.8.5 遍历和遍历过程中的动作</h4><h4 id="2-8-6_封装分析">2.8.6 封装分析</h4><h4 id="2-8-7_Visitor类及其子类">2.8.7 Visitor类及其子类</h4><h4 id="2-8-8_Visitor模式">2.8.8 Visitor模式</h4><h3 id="2-9_小结">2.9 小结</h3><ul>
<li>Composite</li>
<li>Strategy</li>
<li>Decorator</li>
<li>Abstract Factory</li>
<li>Bridge</li>
<li>Command</li>
<li>Iterator</li>
<li>Visitor</li>
</ul>
<h2 id="第3章_创建型模式">第3章 创建型模式</h2><h3 id="3-1_ABSTRACT_FACTORY(抽象工厂)_-_对象创建型模式">3.1 ABSTRACT FACTORY(抽象工厂) - 对象创建型模式</h3><h4 id="意图">意图</h4><p>提供一个创建一系列相关或相互依赖对象的接口, 而无需指定他们具体的类.</p>
<h4 id="别名">别名</h4><p>Kit</p>
<h4 id="动机">动机</h4><p>支持多种视感</p>
<h4 id="适用性">适用性</h4><ul>
<li>一个系统要独立于它的产品的创建, 组合和表示时</li>
<li>一个系统要由多个产品系列的一个来配置时</li>
<li>当你要强调一系列相关的产品对象的设计一边进行联合使用时</li>
<li>当你提供一个产品类库, 而只想显示它们的接口而不是实现时</li>
</ul>
<h4 id="结构">结构</h4><p>AbstractFactory抽象类</p>
<h4 id="参与者">参与者</h4><ul>
<li>AbstractFactory: 创造产品对象的操作接口</li>
<li>ConcreteFactory: 实现具体产品对象的操作</li>
<li>AbstractProduct: 为一类产品对象声明一个接口</li>
<li>ConcreteProduct: 定义一个将被实现的具体工厂创建的产品对象</li>
<li>Client: 仅使用AbstractFactory和AbstractProduct类声明的接口</li>
</ul>
<h4 id="协作">协作</h4><ul>
<li>运行时创建一个ConcreteProduct类的实例</li>
<li>AbstractFactory将产品对象的创建延迟到它的ConcreteProduct子类</li>
</ul>
<h4 id="效果">效果</h4><ol>
<li>分离具体的类</li>
<li>易于交换产品系列</li>
<li>有利于产品的一致性</li>
<li>难以支持新种类的产品</li>
</ol>
<h4 id="实现">实现</h4><ol>
<li>将工厂作为单件</li>
<li>创建产品</li>
<li>定义可扩展的工厂</li>
</ol>
<h4 id="代码示例">代码示例</h4><h4 id="已知应用">已知应用</h4><h4 id="相关模式">相关模式</h4><ul>
<li>Factory Method</li>
<li>Prototype</li>
<li>Singleton</li>
</ul>
<h3 id="3-2_BUILDER(生成器)_-_对象创建型模式">3.2 BUILDER(生成器) - 对象创建型模式</h3><h4 id="意图-1">意图</h4><p>将一个复杂对象的构建和它的表示分离, 使得同样的构建过程可以创建不同的表示.</p>
<h4 id="动机-1">动机</h4><h4 id="适用性-1">适用性</h4><ul>
<li>当创建复杂对象的算法应该独立于该对象的组成部分以及他们的装配方式时</li>
<li>当构造过程必须允许构造的对象有不同的表示时</li>
</ul>
<h4 id="结构-1">结构</h4><h4 id="参与者-1">参与者</h4><ul>
<li>Builder: 为创建一个Product对象的各个部件指定抽象接口</li>
<li>ConcreteBuilder: 实现Builder接口以构造和装配该产品的各个部件/定义并明确他所创建的表示/提供一个检索产品的接口</li>
<li>Director: 构造一个使用Builder接口的对象</li>
<li>Product: 表示被构造的复杂对象</li>
</ul>
<h4 id="协作-1">协作</h4><ul>
<li>客户创建Director对象, 并用她所想要的Builder对像进行配置</li>
<li>一旦产品部件被生成, Director就会通知Builder</li>
<li>Builder处理Director的请求, 并将部件添加到该产品中</li>
<li>客户从生成器中检索产品</li>
</ul>
<h4 id="效果-1">效果</h4><ul>
<li>它使你可以改变一个产品的内部表示</li>
<li>将构造代码和表示代码分开</li>
<li>它使你可以对构造过程进行更精细的控制</li>
</ul>
<h4 id="实现-1">实现</h4><ol>
<li>装配和构造接口</li>
<li>为什么产品没有抽象类</li>
<li>在Builder中缺省的方法为空</li>
</ol>
<h4 id="代码示例-1">代码示例</h4><h4 id="已知应用-1">已知应用</h4><h4 id="相关模式-1">相关模式</h4><ul>
<li>Abstract Factory</li>
<li>Composite</li>
</ul>
<h3 id="3-3_FACTORY_METHOD(工厂方法)_-_对象创建型模式">3.3 FACTORY METHOD(工厂方法) - 对象创建型模式</h3><h4 id="意图-2">意图</h4><p>定义一个用于创建对象的接口, 让子类决定实例化哪一个累.</p>
<h4 id="别名-1">别名</h4><p>虚构造器</p>
<h4 id="动机-2">动机</h4><h4 id="适用性-2">适用性</h4><ul>
<li>当一个类不知道它所必须创建的对象的类的时候</li>
<li>当一个类希望由它的子类来指定他所创建的对象的时候</li>
<li>当类将创建对象的职责委托给多个帮助子类中的某一个, 并且你希望将哪一个帮助子类是代理者这一信息局部化的时候</li>
</ul>
<h4 id="结构-2">结构</h4><h4 id="参与者-2">参与者</h4><ul>
<li>Product: 定义工厂方法所创建的对象的接口</li>
<li>ConcreteProduct: 实现Product的接口</li>
<li>Creator: 声明工厂方法, 该方法返回一个Product类型的对象</li>
<li>ConcreteCreator: 重定义工厂方法以返回一个ConcreteProduct的实例</li>
</ul>
<h4 id="协作-2">协作</h4><ul>
<li>Creator依赖于它的子类来定义工厂方法, 所以它返回一个适当的ConcreteProduct的实例</li>
</ul>
<h4 id="效果-2">效果</h4><ol>
<li>为子类提供挂钩</li>
<li>连接平行的类层次</li>
</ol>
<h4 id="实现-2">实现</h4><ol>
<li>主要有两种不同的情况(Creator类抽象/具体)</li>
<li>参数化工厂方法</li>
<li>特定语言的变化和问题</li>
<li>使用模板以避免创建子类</li>
<li>命名约定</li>
</ol>
<h4 id="代码示例-2">代码示例</h4><h4 id="已知应用-2">已知应用</h4><h4 id="相关模式-2">相关模式</h4><ul>
<li>Abstract Factory</li>
<li>Template Methods</li>
<li>Prototypes</li>
</ul>
<h3 id="3-4_PROTOTYPE(原型)_-_对象创建型模式">3.4 PROTOTYPE(原型) - 对象创建型模式</h3><h4 id="意图-3">意图</h4><h3 id="4-2_BRIDGE(桥接)_-_对象结构型模式">4.2 BRIDGE(桥接) - 对象结构型模式</h3><h4 id="意图-4">意图</h4><p>将抽象部分与它的实现部分分离, 使他们都可以独立的变化.</p>
<h4 id="别名-2">别名</h4><ul>
<li>Handle</li>
<li>Body</li>
</ul>
<h4 id="动机-3">动机</h4><p>规避继承的缺陷</p>
<h4 id="适用性-3">适用性</h4><ul>
<li>取消抽象和实现之间的绑定</li>
<li>抽象和实现都可以通过生成子类的方式进行扩展</li>
<li>抽象实现的修改不影响客户代码</li>
<li>隐藏实现部分</li>
</ul>
<h4 id="结构-3">结构</h4><ul>
<li>Abstraction</li>
<li>Implementor</li>
</ul>
<h4 id="参与者-3">参与者</h4><ul>
<li>Abstraction: 定义抽象类的接口/维护一个指向Implementor类型的对象</li>
<li>RefinedAbstraction: 扩展由Abstraction定义的接口</li>
<li>Implementor: 定义实现类的接口</li>
<li>ConcreteImplementor: 实现Implementor接口并定义它的具体实现</li>
</ul>
<h4 id="协作-3">协作</h4><p>Abstraction将Client的请求转发给它的Implementor对象</p>
<h4 id="效果-3">效果</h4><ul>
<li>分离接口和实现部分</li>
<li>提高可扩展性</li>
<li>实现细节对客户透明</li>
</ul>
<h4 id="实现-3">实现</h4><ol>
<li>仅有一个Implementor</li>
<li>创建正确的Implementor对象</li>
<li>共享Implementor对象</li>
<li>采用多重继承机制</li>
</ol>
<h4 id="代码示例-3">代码示例</h4><h4 id="已知应用-3">已知应用</h4><h4 id="相关模式-3">相关模式</h4><ul>
<li>Abstraction Factory</li>
<li>Adapter</li>
</ul>
<h3 id="4-3_COMPOSITE(组合)_-_对象结构型模式">4.3 COMPOSITE(组合) - 对象结构型模式</h3><ul>
<li>递归定义</li>
</ul>
<h4 id="意图-5">意图</h4><p>树状结构表示”部分-整体”层次结构</p>
<h4 id="动机-4">动机</h4><p>合并图元对象和容器对象</p>
<h4 id="适用性-4">适用性</h4><ul>
<li>整体-部分层次结构</li>
<li>忽略组合对象和单个对象</li>
</ul>
<h4 id="结构-4">结构</h4><p>树状</p>
<h4 id="参与者-4">参与者</h4><ul>
<li>Component</li>
<li>Leaf</li>
<li>Composite</li>
<li>Client</li>
</ul>
<h4 id="协作-4">协作</h4><p>树状结构传递消息</p>
<h4 id="效果-4">效果</h4><ul>
<li>类层次结构</li>
<li>简化客户代码</li>
<li>容易添加新组件</li>
<li>设计一般化</li>
</ul>
<h4 id="实现-4">实现</h4><ol>
<li>显式的父部件引用(注意维护父子节点引用的不变式)</li>
<li>共享组件(多个父部件引用)</li>
<li>最大化Component接口</li>
<li>声明管理子部件的操作</li>
<li>Component是否应该实现一个Component列表</li>
<li>子部件排序</li>
<li>使用高速缓冲存储改善性能</li>
<li>应该由谁删除Component</li>
<li>存储组件最好用哪一种数据结构</li>
</ol>
<h4 id="代码示例-4">代码示例</h4><h4 id="已知应用-4">已知应用</h4><h4 id="相关模式-4">相关模式</h4><ul>
<li>Responsibility of Chain</li>
<li>Decorator</li>
<li>Flyweight</li>
<li>Iterator</li>
<li>Visitor</li>
</ul>
<h3 id="4-4_DECORATOR(装饰)_-_对象结构型模式">4.4 DECORATOR(装饰) - 对象结构型模式</h3><h4 id="意图-6">意图</h4><p>动态的给一个对象添加一些额外的职责</p>
<h4 id="别名-3">别名</h4><ul>
<li>包装器 Wrapper</li>
</ul>
<h4 id="动机-5">动机</h4><p>对一个对象动态的添加额外的功能</p>
<h4 id="适用性-5">适用性</h4><p>替代生成子类, 达到添加职责的功能</p>
<h4 id="结构-5">结构</h4><h4 id="参与者-5">参与者</h4><ul>
<li>Component</li>
<li>ConcreteComponent</li>
<li>Decorator</li>
<li>ConcreteDecorator</li>
</ul>
<h4 id="协作-5">协作</h4><p>转发请求后可以执行额外的操作</p>
<h4 id="效果-5">效果</h4><ol>
<li>比静态继承更灵活</li>
<li>避免在层级结构高层的类有太多的特征</li>
<li>Decorator与它的Component不一样</li>
<li>有许多小对象</li>
</ol>
<h4 id="实现-5">实现</h4><ol>
<li>接口的一致性</li>
<li>省略抽象的Decorator类</li>
<li>保持Component类的简单性</li>
<li>改变对象外壳和改变对象内核</li>
</ol>
<h4 id="代码示例-5">代码示例</h4><h4 id="已知应用-5">已知应用</h4><h4 id="相关模式-5">相关模式</h4><ul>
<li>Adapter</li>
<li>Composite</li>
<li>Strategy</li>
</ul>
<h3 id="5-2_COMMAND(命令)_-_对象行为型模式">5.2 COMMAND(命令) - 对象行为型模式</h3><h4 id="意图-7">意图</h4><p>将一个请求封装为一个对象, 从而使你可以用不同的请求对客户端进行参数化; 对请求排队或记录请求日志, 以及支持可撤销的操作.</p>
<h4 id="别名-4">别名</h4><ul>
<li>Action</li>
<li>Transaction</li>
</ul>
<h4 id="动机-6">动机</h4><p>分离界面和逻辑</p>
<h4 id="适用性-6">适用性</h4><ul>
<li>抽象出待执行的动作以参数化某对象</li>
<li>在不同的时刻指定, 排列和执行请求</li>
<li>支持取消操作</li>
<li>支持修改日志</li>
<li>支持事务系统</li>
</ul>
<h4 id="结构-6">结构</h4><h4 id="参与者-6">参与者</h4><ul>
<li>Command: 声明执行操作的接口</li>
<li>ConcreteCommand: 将一个接受者对象绑定一个动作, 调用接受者相应的操作, 以实现Execute</li>
<li>Client: 创建一个具体命令对象并设定它的接受者</li>
<li>Invoker: 要求该命令执行这个请求</li>
<li>Receiver: 知道如何实施与执行一个请求相关的操作</li>
</ul>
<h4 id="协作-6">协作</h4><ul>
<li>Client创建一个ConcreteCommand对象并指定它的Receiver对象</li>
<li>某Invoker对象存储该ConcreteCommand对象</li>
<li>该Invoker通过调用Command对象的Execute操作来提交一个请求</li>
<li>ConcreteCommand对象调用它的Receiver的一些操作以执行该请求</li>
</ul>
<h4 id="效果-6">效果</h4><ul>
<li>Command模式将调用操作的对象与知道如何实现该操作的对象解耦</li>
<li>Command是头等的对象, 他们可以像其他的对象一样被操作盒扩展</li>
<li>可以将多个命令封装成一个复合命令</li>
<li>容易添加新的Command</li>
</ul>
<h4 id="实现-6">实现</h4><ul>
<li>一个命令对象应达到何种智能程度</li>
<li>支持取消和重做, 有时需要拷贝命令(删除)</li>
<li>避免取消操作过程中的错误积累</li>
<li>使用C++模板</li>
</ul>
<h4 id="代码示例-6">代码示例</h4><h4 id="已知应用-6">已知应用</h4><h4 id="相关模式-6">相关模式</h4><ul>
<li>Composite模式</li>
<li>Memento模式</li>
</ul>
<h3 id="5-4_ITERATOR(迭代器)_-_对象行为型模式">5.4 ITERATOR(迭代器) - 对象行为型模式</h3><h4 id="意图-8">意图</h4><p>提供一种方法顺序访问一个聚合对象中各个元素, 而又不暴露该对象内部的表示</p>
<h4 id="别名-5">别名</h4><ul>
<li>Cursor</li>
</ul>
<h4 id="动机-7">动机</h4><h4 id="适用性-7">适用性</h4><ul>
<li>访问一个聚合对象的内容二无需暴露他的内部接口</li>
<li>支持对聚合对象的多种遍历</li>
<li>为遍历不同的聚合结构提供一个统一的接口</li>
</ul>
<h4 id="结构-7">结构</h4><h4 id="参与者-7">参与者</h4><ul>
<li>Iterator: 迭代器定义访问和遍历元素的接口</li>
<li>ConcreteIterator: 具体迭代器实现迭代器接口/对该聚合遍历时跟踪当前位置</li>
<li>Aggregate: 聚合定义创建相应迭代器对象的接口</li>
<li>ConcreteAggregate: 具体聚合实现创建迭代器的接口, 该操作返回ConcreteIterator的一个适当的实例</li>
</ul>
<h4 id="协作-7">协作</h4><h4 id="效果-7">效果</h4><ul>
<li>支持以不同的方式遍历一个聚合</li>
<li>迭代器简化了聚合的接口</li>
<li>在同一个聚合上可以有多个遍历</li>
</ul>
<h4 id="实现-7">实现</h4><ol>
<li>谁控制该迭代器(内部/外部)</li>
<li>谁定义遍历算法(迭代器/聚合)</li>
<li>迭代器健壮程度如何(聚合的插入删除干扰遍历)</li>
<li>附加的迭代器操作(Previous/SkipTo…)</li>
<li>在C++中使用多态迭代器</li>
<li>迭代器可有特权访问</li>
<li>用于符合对象的迭代器</li>
<li>空迭代器</li>
</ol>
<h4 id="代码示例-7">代码示例</h4><h4 id="已知应用-7">已知应用</h4><h4 id="相关模式-7">相关模式</h4><ul>
<li>Composite</li>
<li>Factory Method</li>
<li>Memento</li>
</ul>
<h3 id="5-9_STRATEGY(策略)_-_对象行为型模式">5.9 STRATEGY(策略) - 对象行为型模式</h3><h4 id="意图-9">意图</h4><p>封装可独立替换的算法</p>
<h4 id="别名-6">别名</h4><ul>
<li>Policy 政策</li>
</ul>
<h4 id="动机-8">动机</h4><ul>
<li>保持逻辑的精简</li>
<li>灵活替换算法</li>
</ul>
<h4 id="适用性-8">适用性</h4><h4 id="结构-8">结构</h4><h4 id="参与者-8">参与者</h4><ul>
<li>Strategy</li>
<li>ConcreteStrategy</li>
<li>Context</li>
</ul>
<h4 id="协作-8">协作</h4><p>Context自身引用传递给Strategy</p>
<h4 id="效果-8">效果</h4><h4 id="实现-8">实现</h4><h4 id="代码示例-8">代码示例</h4><h4 id="已知应用-8">已知应用</h4><h4 id="相关模式-8">相关模式</h4><h3 id="5-11_VISITOR(访问者)_-_对象行为型模式">5.11 VISITOR(访问者) - 对象行为型模式</h3><h4 id="意图-10">意图</h4><p>表示一个作用于某对象结构中的各元素的操作. 它使你可以在不改变元素的类的前提下定义作用于这些元素的新操作</p>
<h4 id="动机-9">动机</h4><h4 id="适用性-9">适用性</h4><ul>
<li>一个对象结构包含很多类对象, 他们有不同的接口, 而你想对这些对象实施一些依赖于其具体类的操作</li>
<li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作</li>
<li>定义对象结构的类很少改变, 但经常需要在此结构上定义新的操作</li>
</ul>
<h4 id="结构-9">结构</h4><h4 id="参与者-9">参与者</h4><ul>
<li>Visitor: 为该对象结构中ConcreteElement的没一个类声明一个Visit操作</li>
<li>ConcreteVisitor: 实现每个由Visitor声明的操作</li>
<li>Element: 定义一个Accept操作, 他以一个访问者为参数</li>
<li>ConcreteElement: 实现Accept操作</li>
<li>ObjectStructure: 能够枚举元素</li>
</ul>
<h4 id="协作-9">协作</h4><ul>
<li>客户创建一个ConcreteVisitor</li>
<li>元素创建Accept操作, 调用Visitor</li>
</ul>
<h4 id="效果-9">效果</h4><ol>
<li>访问者模式使得易于增加新的操作</li>
<li>访问者集中相关的操作而分离无关的操作</li>
<li>增加新的ConcreteElement类很困难</li>
<li>通过类层次进行访问</li>
<li>积累状态</li>
<li>破坏封装</li>
</ol>
<h4 id="实现-9">实现</h4><h4 id="示例代码">示例代码</h4><h4 id="已知应用-9">已知应用</h4><h4 id="相关模式-9">相关模式</h4><ul>
<li>Composite</li>
<li>Interpreter</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[设计模式读书笔记]]>
    
    </summary>
    
      <category term="编程" scheme="http://daiker0330.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://daiker0330.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="读书笔记" scheme="http://daiker0330.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="读书笔记" scheme="http://daiker0330.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[HelloWorld]]></title>
    <link href="http://daiker0330.github.io/2015/07/26/HelloWorld/"/>
    <id>http://daiker0330.github.io/2015/07/26/HelloWorld/</id>
    <published>2015-07-26T14:39:09.000Z</published>
    <updated>2015-07-26T15:33:41.055Z</updated>
    <content type="html"><![CDATA[<h1 id="Hello_Blog">Hello Blog</h1><p>This is the first page of my Blog.</p>
<p>Writing 1,000 words a day to change my life!</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Hello_Blog">Hello Blog</h1><p>This is the first page of my Blog.</p>
<p>Writing 1,000 words a day to change my life!</p>
]]>
    </summary>
    
  </entry>
  
</feed>